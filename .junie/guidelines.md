---

# **项目指南：BPoSt - 基于区块链的完全公开存储时间证明共识协议**

## **1. 项目概述与核心目标**

本项目旨在从零开始构建一个名为 **BPoSt (Blockchain-based Proof of Storage-time)**
的共识协议。该协议的核心目标是利用区块链技术，创建一个去中心化的、完全公开可验证的、对用户友好的、且支持随时核查的存储网络。

BPoSt协议将结合**分布式可证明数据持有 (Distributed PDP)**、**低方差挖矿机制 (Bobtail)** 和 **增量可验证计算的折叠方案 (
IVC with Folding Scheme)**，以解决传统分布式存储在无需许可网络环境下的数据可靠性、验证有效性和用户预处理开销等问题。

## **2. 协议角色定义**

协议的参与者分为以下几类：

* **文件所有者 (File Owner):** 存储需求方。由于自身存储空间有限，希望将大文件安全地存储在网络中。其主要职责是对文件进行预处理（分块、签名），然后将数据和验证元数据发布到网络。
* **存储节点 (Storage Node):** 存储供给方。通过贡献闲置存储空间来获得收益。根据其在共识过程中的具体行为，存储节点可以进一步细分为：
    * **领导者 (Leader):** 在每一轮共识中，通过PoW竞争被选出的单个节点。负责收集和验证该轮次中其他优胜节点（Providers）的证明，并将这些信息打包成新区块。
    * **提供者 (Provider):** 提交了PoW“抽签”但未成为Leader，但其结果在全局最优的`k`个之内，因此被选中。需要向Leader提交本轮完成的状态树以供验证和上链。
    * **观察者 (Observer):** 既未成为Leader也未成为Provider的存储节点，或任何外部用户。可以利用协议的公开可验证性，监督链上证明，并提交作恶证明以获取奖励。

## **3. 核心模块与实现**

整个协议在逻辑上可分为三个核心模块：**证明 (Proof)**、**共识 (Consensus)** 和 **聚合 (Aggregation)**。

### **模块一：证明 - 分布式可证明数据持有 (dPDP)**

此模块负责实现单个轮次内的存储证明，即“空间”维度的证明。

#### **3.1. 设置 (Setup)**

1. **密钥生成:** 文件所有者运行`KeyGen`算法生成公私钥对`(pk, sk)`。同时，选择一个双线性映射`e: G x G -> G_T`，并定义生成元
   `g`和`u`。私钥为`α`，公钥包含`β = g^α`等参数。
2. **文件预处理:** 文件所有者将文件`f`分割成`m`个数据块`b_1, b_2, ..., b_m`。
3. **标签生成:** 对每一个数据块`b_i`，所有者使用私钥`α`计算签名`σ_i = [H_1(i) * u^(b_i)]^α`。
4. **数据发布:** 文件所有者将文件块集合`{b_i}`、签名集合`{σ_i}`以及公钥`pk`和相关公共参数发布到区块链网络。此后，所有者可以安全地删除本地文件。

#### **3.2. 证明生成 (Proof Generation)**

1. **公共挑战生成:** 在每个新的区块高度`r`，网络中的**任何节点**（包括存储节点自身）都可以使用公开的上一区块哈希
   `H(Block_r-1)`作为随机种子，计算出本轮的挑战`chal`。这是一个伪随机过程，确保了挑战的公开性和不可预测性。
2. **证明计算:** 收到挑战后，存储节点对被挑战的文件块集合执行`GenProof`算法，生成一个聚合证明`pf = (μ, σ)`，其中`μ`是聚合数据块，
   `σ`是聚合签名。
3. **证明广播:** 存储节点将生成的证明`pf`广播到网络中，准备参与共识。

#### **3.3. 证明验证 (Verification)**

网络中的**任何节点**都可以运行`CheckProof`算法，使用公钥`pk`和本轮的公共挑战`chal`来验证收到的证明`pf`
是否有效。验证通过一个基于双线性映射的等式进行，确保了存储的公开可验证性。

### **模块二：共识 - 低方差PoW与状态树 (Bobtail)**

此模块负责将各个节点的存储证明打包上链，并构成了协议的“时间”维度。

#### **4.1. 多维状态树 (Multidimensional State Trees)**

为了有效组织和证明一个节点在一段时间内存储了大量文件，我们引入多维状态树结构，它基于Merkle树构建。

* **时间状态树 (Time State Tree):**
    * **作用:** 针对**单个文件**，记录其在整个存储周期内的所有证明历史。
    * **构建:**
        1. **初始承诺:** 存储节点接收到文件后，为文件的**所有**数据块生成初始的dPDP签名，并构建一棵Merkle树，其根代表了对文件存储的初始承诺。
        2. **状态更新:** 在后续的每一轮中，节点为被挑战的文件块生成新的dPDP证明，并将这些新证明更新到时间状态树的相应叶子节点上。树根会随之更新，反映文件的最新存储状态。
    * **用途:** 时间状态树的根是需要被包含在新区块中的核心内容，用于公开验证该文件在本轮的存储状态。

* **存储状态树 (Storage State Tree):**
    * **作用:** 针对**单个存储节点**，衡量其在特定时间点（即某一轮次）的总存储贡献。
    * **构建:** 在每一轮，节点将它所存储的**所有文件**的**时间状态树的树根**作为叶子节点，构建成一棵更高维度的存储状态树。
    * **用途:** 这棵树的根和叶子数量将作为节点参与PoW竞争的权重。

#### **4.2. 低方差PoW (Bobtail机制)**

为了解决传统PoW区块间隔方差过大导致的不公平性，我们采用Bobtail机制来选举Leader和生产区块。

1. **入场券/抽签 (Lots):**
    * 一个存储节点在本轮可以生成的“抽签”数量，与其**存储状态树**的叶子节点数量（即存储的文件数量）成正比。这鼓励节点存储更多文件以提高竞争力。
    * 每个“抽签”是一个PoW计算过程：`hash(nonce, storage_state_tree_root)`。
2. **区块生成条件:**
    * 全网节点将自己计算出的最优“抽签”结果（最低的哈希值）进行广播。
    * 当网络中收集到的最优`k`个“抽签”结果的**平均值**小于等于当前网络难度`t_k`时，就满足了出块条件。
    * 这种基于`k`个最优解平均值的判断标准，可以使区块间隔的方差以`O(1/k)`的速度递减，从而让区块的生成速率更接近客观时间流逝。
3. **Leader选举:**
    * 在满足出块条件的`k`个最优“抽签”中，提交了**单个最低哈希值**的节点成为本轮的**Leader**。
4. **区块构建:**
    * Leader负责收集这`k`个最优“抽签”对应的**Provider**节点的信息。
    * Leader验证这些Provider提交的**时间状态树根**是否有效。
    * 将所有有效的证明信息（主要是时间状态树根）打包成一个新的区块，并签名广播。

### **模块三：聚合 - 增量可验证计算 (IVC with Folding)**

此模块用于解决验证效率问题。随着存储时间的推移，一个文件的证明链会变得非常长，要求用户遍历所有相关区块进行验证是不现实的。我们采用基于
**Nova折叠方案**的IVC来解决此问题。

1. **迭代证明生成 (Iterative Proof Generation):**
    * 在**每一轮**（每个区块高度`i`），存储节点在生成dPDP证明的同时，还需要运行IVC的证明算法`NIFS.P`。
    * 该算法会将**上一轮的累积证明** `(U_i-1, W_i-1)` 与**本轮新生成的单步证明** `(u_i-1, w_i-1)`
      进行“折叠”，生成一个新的、大小不变的累积证明 `(U_i, W_i)`。
    * 这个过程将巨大的验证工作量分散到每个出块周期中，避免了最后一次性生成证明的高额开销。

2. **证明压缩与最终验证 (Proof Compression & Final Verification):**
    * **最终折叠:** 当存储周期结束时（例如合约到期），存储节点执行最后一次折叠，将最终的累积证明和单步证明合并成一个最终的、完全累积的实例-证据对
      `(U', W')`。
    * **生成简洁证明:** 节点随后针对这个最终的`(U', W')`，使用一个为松弛R1CS定制的ZK-SNARK证明算法，生成一个非常简短的、零知识的最终证明
      `π_final`。
    * **用户验证:** 文件所有者（或任何观察者）接收这个简洁证明`π_final`。验证者只需运行高效的`NIFS.V`
      算法，即可快速验证整个存储周期的所有证明是否全部正确，而无需访问和计算历史区块链数据。

## **5. 完整协议流程**

1. **预备阶段 (Pre-Prepare):**
    * 用户选择文件`F`，运行dPDP的预处理，生成文件块和签名。
    * 用户将数据和元数据发布到网络。
    * 存储节点接收数据，构建初始的时间状态树作为承诺，并调用`NIFS.K`生成IVC所需的密钥。

2. **存储与证明阶段 (Storage and Proof):**
    * 协议按区块高度周期性运行。
    * 在每个区块高度`i`，存储节点根据`H(Block_i-1)`生成公共挑战。
    * 节点为被挑战的文件块生成dPDP证明，并更新对应文件的**时间状态树**。
    * 节点运行`NIFS.P`来迭代地**折叠**IVC证明，更新累积证明。
    * 节点根据其所有文件的**时间状态树根**构建**存储状态树**。
    * 所有节点使用其**存储状态树根**进行PoW（Bobtail）竞争。

3. **共识与出块阶段 (Consensus and Block Production):**
    * 当网络中最优的`k`个PoW结果的平均值满足难度要求时，触发Leader选举。
    * 产生最低哈希值的节点成为Leader。
    * Leader收集`k`个Providers的**时间状态树根**，验证后打包成新区块并广播。

4. **最终验证阶段 (Final Verification):**
    * 存储周期结束。
    * 存储节点执行最后一次证明折叠，并生成一个简洁的ZK-SNARK证明`π_final`。
    * 节点将`π_final`发送给用户。
    * 用户运行`NIFS.V`进行快速、高效的最终验证。